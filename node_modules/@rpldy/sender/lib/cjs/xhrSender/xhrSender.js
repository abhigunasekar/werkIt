"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.SUCCESS_CODES = void 0;

var _shared = require("@rpldy/shared");

var _consts = require("../consts");

var _MissingUrlError = _interopRequireDefault(require("../MissingUrlError"));

var _prepareFormData = _interopRequireDefault(require("./prepareFormData"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SUCCESS_CODES = [200, 201, 202, 203, 204];
exports.SUCCESS_CODES = SUCCESS_CODES;

var getRequestData = function (items, options) {
  var data;

  if (options.sendWithFormData) {
    _shared.logger.debugLog("uploady.sender: sending ".concat(items.length, " item(s) as form data"));

    data = (0, _prepareFormData["default"])(items, options);
  } else {
    if (items.length > 1) {
      throw new Error("XHR Sender - Request without form data can only contain 1 item. received ".concat(items.length));
    }

    var item = items[0];

    _shared.logger.debugLog("uploady.sender: sending item ".concat(item.id, " as request body"));

    data = item.file || item.url;
  }

  return data;
};

var makeRequest = function (items, url, options, onProgress, config) {
  var xhr;
  var data = (config === null || config === void 0 ? void 0 : config.getRequestData) ? config.getRequestData(items, options) : getRequestData(items, options);

  var issueRequest = function () {
    var requestUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : url;
    var requestData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : data;
    var requestOptions = arguments.length > 2 ? arguments[2] : undefined;
    requestOptions = (0, _shared.merge)(_objectSpread(_objectSpread({}, (0, _shared.pick)(options, ["method", "headers", "withCredentials"])), {}, {
      preSend: function preSend(req) {
        req.upload.onprogress = function (e) {
          if (e.lengthComputable && onProgress) {
            onProgress(e, items.slice());
          }
        };
      }
    }), requestOptions);
    var realPXhr = (0, _shared.request)(requestUrl, requestData, requestOptions); // $FlowFixMe -

    xhr = realPXhr.xhr;
    return realPXhr;
  }; //pXhr is a promise that resolves to the upload XHR


  var pXhr = (config === null || config === void 0 ? void 0 : config.preRequestHandler) ? config.preRequestHandler(issueRequest, items, url, options, onProgress, config) : issueRequest();
  return {
    url: url,
    count: items.length,
    pXhr: pXhr,
    getXhr: function getXhr() {
      return xhr;
    },
    aborted: false
  };
};

var parseResponseJson = function (response, headers, options) {
  var parsed = response;
  var ct = headers === null || headers === void 0 ? void 0 : headers["content-type"];

  if (options.forceJsonResponse || (ct === null || ct === void 0 ? void 0 : ct.includes("json"))) {
    try {
      parsed = JSON.parse(response);
    } catch (_unused) {//silent fail
    }
  }

  return parsed;
};

var processResponse = function (sendRequest, options) {
  return sendRequest.pXhr.then(function (xhr) {
    var _options$formatServer, _options$formatServer2;

    var state, response, status;

    _shared.logger.debugLog("uploady.sender: received upload response ", xhr);

    state = ~SUCCESS_CODES.indexOf(xhr.status) ? _shared.FILE_STATES.FINISHED : _shared.FILE_STATES.ERROR;
    status = xhr.status;
    var resHeaders = (0, _shared.parseResponseHeaders)(xhr);
    response = {
      data: (_options$formatServer = (_options$formatServer2 = options.formatServerResponse) === null || _options$formatServer2 === void 0 ? void 0 : _options$formatServer2.call(options, xhr.response, status, resHeaders)) !== null && _options$formatServer !== void 0 ? _options$formatServer : parseResponseJson(xhr.response, resHeaders, options),
      headers: resHeaders
    };
    return {
      status: status,
      state: state,
      response: response
    };
  })["catch"](function (error) {
    var state, response;

    if (sendRequest.aborted) {
      state = _shared.FILE_STATES.ABORTED;
      response = "aborted";
    } else {
      _shared.logger.debugLog("uploady.sender: upload failed: ", error);

      state = _shared.FILE_STATES.ERROR;
      response = error;
    }

    return {
      error: true,
      state: state,
      response: response,
      status: 0
    };
  });
};

var abortRequest = function (sendRequest) {
  var abortCalled = false;
  var aborted = sendRequest.aborted,
      getXhr = sendRequest.getXhr;
  var xhr = getXhr();

  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {
    _shared.logger.debugLog("uploady.sender: cancelling request with ".concat(sendRequest.count, " items to: ").concat(sendRequest.url));

    xhr.abort();
    sendRequest.aborted = true;
    abortCalled = true;
  }

  return abortCalled;
};

var getXhrSend = function (config) {
  return function (items, url, options, onProgress) {
    if (!url) {
      throw new _MissingUrlError["default"](_consts.XHR_SENDER_TYPE);
    }

    _shared.logger.debugLog("uploady.sender: sending file: ", {
      items: items,
      url: url,
      options: options
    });

    var sendRequest = makeRequest(items, url, options, onProgress, config);
    return {
      request: processResponse(sendRequest, options),
      abort: function abort() {
        return abortRequest(sendRequest);
      },
      senderType: _consts.XHR_SENDER_TYPE
    };
  };
};

var _default = getXhrSend;
exports["default"] = _default;