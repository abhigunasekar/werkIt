function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { logger, FILE_STATES, request, parseResponseHeaders, pick, merge } from "@rpldy/shared";
import { XHR_SENDER_TYPE } from "../consts";
import MissingUrlError from "../MissingUrlError";
import prepareFormData from "./prepareFormData";
export var SUCCESS_CODES = [200, 201, 202, 203, 204];

var getRequestData = function (items, options) {
  var data;

  if (options.sendWithFormData) {
    logger.debugLog("uploady.sender: sending ".concat(items.length, " item(s) as form data"));
    data = prepareFormData(items, options);
  } else {
    if (items.length > 1) {
      throw new Error("XHR Sender - Request without form data can only contain 1 item. received ".concat(items.length));
    }

    var item = items[0];
    logger.debugLog("uploady.sender: sending item ".concat(item.id, " as request body"));
    data = item.file || item.url;
  }

  return data;
};

var makeRequest = function (items, url, options, onProgress, config) {
  var xhr;
  var data = (config === null || config === void 0 ? void 0 : config.getRequestData) ? config.getRequestData(items, options) : getRequestData(items, options);

  var issueRequest = function () {
    var requestUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : url;
    var requestData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : data;
    var requestOptions = arguments.length > 2 ? arguments[2] : undefined;
    requestOptions = merge(_objectSpread(_objectSpread({}, pick(options, ["method", "headers", "withCredentials"])), {}, {
      preSend: function preSend(req) {
        req.upload.onprogress = function (e) {
          if (e.lengthComputable && onProgress) {
            onProgress(e, items.slice());
          }
        };
      }
    }), requestOptions);
    var realPXhr = request(requestUrl, requestData, requestOptions); // $FlowFixMe -

    xhr = realPXhr.xhr;
    return realPXhr;
  }; //pXhr is a promise that resolves to the upload XHR


  var pXhr = (config === null || config === void 0 ? void 0 : config.preRequestHandler) ? config.preRequestHandler(issueRequest, items, url, options, onProgress, config) : issueRequest();
  return {
    url: url,
    count: items.length,
    pXhr: pXhr,
    getXhr: function getXhr() {
      return xhr;
    },
    aborted: false
  };
};

var parseResponseJson = function (response, headers, options) {
  var parsed = response;
  var ct = headers === null || headers === void 0 ? void 0 : headers["content-type"];

  if (options.forceJsonResponse || (ct === null || ct === void 0 ? void 0 : ct.includes("json"))) {
    try {
      parsed = JSON.parse(response);
    } catch (_unused) {//silent fail
    }
  }

  return parsed;
};

var processResponse = function (sendRequest, options) {
  return sendRequest.pXhr.then(function (xhr) {
    var _options$formatServer, _options$formatServer2;

    var state, response, status;
    logger.debugLog("uploady.sender: received upload response ", xhr);
    state = ~SUCCESS_CODES.indexOf(xhr.status) ? FILE_STATES.FINISHED : FILE_STATES.ERROR;
    status = xhr.status;
    var resHeaders = parseResponseHeaders(xhr);
    response = {
      data: (_options$formatServer = (_options$formatServer2 = options.formatServerResponse) === null || _options$formatServer2 === void 0 ? void 0 : _options$formatServer2.call(options, xhr.response, status, resHeaders)) !== null && _options$formatServer !== void 0 ? _options$formatServer : parseResponseJson(xhr.response, resHeaders, options),
      headers: resHeaders
    };
    return {
      status: status,
      state: state,
      response: response
    };
  })["catch"](function (error) {
    var state, response;

    if (sendRequest.aborted) {
      state = FILE_STATES.ABORTED;
      response = "aborted";
    } else {
      logger.debugLog("uploady.sender: upload failed: ", error);
      state = FILE_STATES.ERROR;
      response = error;
    }

    return {
      error: true,
      state: state,
      response: response,
      status: 0
    };
  });
};

var abortRequest = function (sendRequest) {
  var abortCalled = false;
  var aborted = sendRequest.aborted,
      getXhr = sendRequest.getXhr;
  var xhr = getXhr();

  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {
    logger.debugLog("uploady.sender: cancelling request with ".concat(sendRequest.count, " items to: ").concat(sendRequest.url));
    xhr.abort();
    sendRequest.aborted = true;
    abortCalled = true;
  }

  return abortCalled;
};

var getXhrSend = function (config) {
  return function (items, url, options, onProgress) {
    if (!url) {
      throw new MissingUrlError(XHR_SENDER_TYPE);
    }

    logger.debugLog("uploady.sender: sending file: ", {
      items: items,
      url: url,
      options: options
    });
    var sendRequest = makeRequest(items, url, options, onProgress, config);
    return {
      request: processResponse(sendRequest, options),
      abort: function abort() {
        return abortRequest(sendRequest);
      },
      senderType: XHR_SENDER_TYPE
    };
  };
};

export default getXhrSend;