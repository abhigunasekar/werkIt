function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import { FILE_STATES } from "./consts";
var BISYM = Symbol["for"]("__rpldy-bi__");
var iCounter = 0;

var getBatchItemWithUrl = function (batchItem, url) {
  batchItem.url = url;
  return batchItem;
};

var getBatchItemWithFile = function (batchItem, file) {
  batchItem.file = file;
  return batchItem;
};

var isLikeFile = function (f) {
  return f && (f instanceof Blob || f instanceof File || _typeof(f) === "object" && f.name && f.type);
};

export default (function (f, batchId) {
  var isPending = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  iCounter += f.id && f.batchId ? 0 : 1; //keep existing id for recycled items

  var id = f.id && f.batchId ? f.id : "".concat(batchId, ".item-").concat(iCounter),
      state = isPending ? FILE_STATES.PENDING : FILE_STATES.ADDED;
  var batchItem = {
    id: id,
    batchId: batchId,
    state: state,
    uploadStatus: 0,
    completed: 0,
    loaded: 0,
    aborted: false,
    recycled: false,
    previousBatch: null
  };
  Object.defineProperty(batchItem, BISYM, {
    value: true,
    //need writable to be able to keep prop when unwrapped from simple-state
    writable: true
  });

  if (_typeof(f) === "object" && f[BISYM] === true) {
    //recycling existing batch item
    batchItem.recycled = true;
    batchItem.previousBatch = f.batchId;
    f = f.file || f.url;
  }

  if (typeof f === "string") {
    batchItem = getBatchItemWithUrl(batchItem, f);
  } else if (isLikeFile(f)) {
    batchItem = getBatchItemWithFile(batchItem, f);
  } else {
    throw new Error("Unknown type of file added: ".concat(_typeof(f)));
  }

  return batchItem;
});