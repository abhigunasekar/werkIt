var _FILE_STATE_TO_EVENT_;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { FILE_STATES, logger } from "@rpldy/shared";
import { UPLOADER_EVENTS, ITEM_FINALIZE_STATES } from "../consts";
import { cleanUpFinishedBatches, incrementBatchFinishedCounter } from "./batchHelpers";
export var FILE_STATE_TO_EVENT_MAP = (_FILE_STATE_TO_EVENT_ = {}, _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.PENDING, null), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ADDED, UPLOADER_EVENTS.ITEM_START), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.FINISHED, UPLOADER_EVENTS.ITEM_FINISH), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ERROR, UPLOADER_EVENTS.ITEM_ERROR), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.CANCELLED, UPLOADER_EVENTS.ITEM_CANCEL), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ABORTED, UPLOADER_EVENTS.ITEM_ABORT), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.UPLOADING, UPLOADER_EVENTS.ITEM_PROGRESS), _FILE_STATE_TO_EVENT_);

var getIsFinalized = function (item) {
  return !!~ITEM_FINALIZE_STATES.indexOf(item.state);
};

var processFinishedRequest = function (queue, finishedData, next) {
  finishedData.forEach(function (itemData) {
    var state = queue.getState();
    var id = itemData.id,
        info = itemData.info;
    logger.debugLog("uploader.processor.queue: request finished for item - ", {
      id: id,
      info: info
    });

    if (state.items[id]) {
      queue.updateState(function (state) {
        var item = state.items[id];
        item.state = info.state;
        item.uploadResponse = info.response;
        item.uploadStatus = info.status;

        if (getIsFinalized(item)) {
          delete state.aborts[id];
        }
      }); //get most up-to-date item data

      var item = queue.getState().items[id];

      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {
        //ensure we trigger progress event with completed = 100 for all items
        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);
      }

      if (FILE_STATE_TO_EVENT_MAP[item.state]) {
        //trigger UPLOADER EVENT for item based on its state
        queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);
      }

      if (getIsFinalized(item)) {
        incrementBatchFinishedCounter(queue, item.batchId); //trigger FINALIZE event

        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);
      }
    }

    var index = state.itemQueue.indexOf(id);

    if (~index) {
      queue.updateState(function (state) {
        state.itemQueue.splice(index, 1);
        var activeIndex = state.activeIds.indexOf(id);

        if (~activeIndex) {
          state.activeIds.splice(activeIndex, 1);
        }
      });
    }
  }); //ensure finished batches are remove from state

  cleanUpFinishedBatches(queue);
  return next(queue);
};

export default processFinishedRequest;